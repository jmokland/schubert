                        Schubert, Version 0.999

                A Maple package for Intersection Theory.

                  Sheldon Katz and Stein Arild Stromme


COPYRIGHT NOTICE:
Copyright (c) 1992 by Sheldon Katz and Stein Arild Stromme

Permission is granted to anyone to use, modify, or redistribute this
software freely, subject to the following restrictions:

1. The authors accept no responsibility for any consequences of this
   software and make no guarantee that the software is free of defects.
2. The origin of this software must not be misrepresented, either by
   explicit claim or by omission.
3. This notice and the copyright must be included in all copies or
   altered versions of this software.
4. This software may not be included or redistributed as part of any
   package to be sold for profit unless the authors have given explicit 
   written permission to do so.
5. If schubert proves useful in your research, the authors would appreciate
   an acknowledgement in published work of your use of schubert.

Acknowledgements: Parts of the Maple symmetric function package SF by
John Stembridge are called by schubert.  Part of the work on schubert
was done while the first author was a visitor at Duke University and
while the second author was a visitor at the University of Utah.

The authors will greatly appreciate reports of any bugs and fixes, as well as
additions that are suitable for inclusion in later versions of schubert.

The current version of schubert will usually be available for 
download at the schubert homepage (http://www.math.uib.no/schubert/).

If you want to be notified of upgrades, send email or ordinary mail 
to one of us.

Addresses:  Department of Mathematics, University of Illinois at Urbana-Champaign,
            Urbana, IL 61801, USA            katz@math.uiuc.edu

            Mathematical Institute, University of Bergen, Johs. Brunsgt. 12,
            N-5008 BERGEN, Norway            stromme@math.uib.no

CONTENTS:

I.    Introduction               
II.   Getting Started            
III.  Examples                   
IV.   Commands overview
V.    Description of all commands 
VI.   Global Variables 
VII.  Troubleshooting          
VIII. Miscellaneous remarks      

I. INTRODUCTION:

The package schubert is designed to handle computations which commonly arise in
intersection theory, especially in algebraic geometry at present. schubert
deals with several data types which will be discussed at greater length later:

sheaf objects 
variety objects 
morphism objects

schubert consists of Maple procedures to create these data types, modify these
data types, and compute with these data types. 

This version was developed for Maple V on three different platforms:
Unix-based SUN and Dec systems, and Apple Macintosh under Mac OS.
However, it should work on any platform running Maple.
The installation procedure described below is only
for Unix-like systems.

These notes are intended to be a temporary substitute for a manual, and may be
used as such until the manual is written.

In these notes, data that the user is required to type during a Maple session
will be indicated by the line beginning with the Maple prompt "> ". The prompt
used for the Unix system will be denoted in this manual by "unix: ".
Familiarity with both Maple and Unix is assumed.

On-line help is available by using the Maple help facility.

> ?commandname or > help(commandname)

will produce some help text. Also, the help command

> ?summary

gives a summary list of commands available in schubert. Rudimentary
help can also be obtained by typing a valid schubert procedure with no
arguments.

For example:

> sheaf();

           usage: sheaf(rank,classes) or sheaf(rank,classes,variety)

An exception to this is the where() procedure, which does not take any
arguments.

The global constant `version_` contains the schubert version number.

II. GETTING STARTED:

The package will be formed by creating the schubert.m file.

To do this under Unix:

Decide which directory you want the schubert package to be located in.  Modify
your .mapleinit file to include this directory in your libname variable.  Be
sure to include the full path name.  For example, if you need no other maple
libraries besides schubert and the built-in ones, and you want schubert in your
directory /u/chasles/schubert/schubertlib, your .mapleinit file might read:

HomeLib:=`/u/chasles/schubert/schubertlib`:
libname:=libname,HomeLib:

Extract schubert.tar in the directory /u/chasles/, change directory to
/u/chasles/schubert and type at the system prompt

unix: make

This creates the schubert package.  You should see the files
schubert.m and maple.hdb in the schubertlib directory.

To use schubert, you need to get into maple, then load the schubert
package via the maple command "with(schubert);".  Currently, the file
SF.m needs to be loaded as well.  For instance, you can put SF.m in
the same directory as schubert.m, and proceed as below.

Warning: SF2.4v.txt renders linalg[diag] unusable; use SF2.4.tar.gz
from <http://www.math.lsa.umich.edu/~jrs/maple.html>. If you unpack it
in /u/chasles/schubert/schubertlib, SF.m lands in the same direcrtory
as schubert.m. If you do this, make sure to rerun make, as an SF
install deletes the schubert help, but not the other way around.

unix: maple
    |\^/|     Maple 11 (X86 64 LINUX)
._|\|   |/|_. Copyright (c) Maplesoft, a division of Waterloo Maple Inc. 2007
 \  MAPLE  /  All rights reserved. Maple is a trademark of
 <____ ____>  Waterloo Maple Inc.
      |       Type ? for help.
> with(schubert): with(SF):

Alternatively, these commands may be placed in your .mapleinit file if you want
to have schubert available every time you use maple.

III.  EXAMPLES:

# Hilbert polynomial and Todd class of projective 3-space P^3.
> 
> proj(3,h,all): factor(chi(o(n*h)));
                          1/6 (n + 3) (n + 2) (n + 1)

> Ph[toddclass_];
                                           2  2    3  3
                         1 + 2 h t + 11/6 h  t  + h  t

#-------------------------------------------------------------------------
# Generation of formulas:
> 
> DIM:=4:
> A:=bundle(2,c):        # a bundle with Chern classes c1,c2 and rank 2
> B:=bundle(3,d):        # a bundle with Chern classes d1,d2,d3 and rank 3
> chern(A);
                                               2
                                1 + c1 t + c2 t

> segre(B);
                             2        2      3                  3
               1 + d1 t + (d1  - d2) t  + (d1  - 2 d1 d2 + d3) t

                         4          2               2   4
                    + (d1  - 3 d2 d1  + 2 d1 d3 + d2 ) t

> chern(A&@B);           # The Chern class of the tensor product
                         2                 2                 2
1 + (2 d1 + 3 c1) t + (d1  + 5 c1 d1 + 3 c1  + 2 d2 + 3 c2) t  +

                         3                           2                    2   3
  (6 c1 c2 + 2 d1 d2 + c1  + 2 d3 + 4 c1 d2 + 2 c1 d1  + 4 d1 c2 + 4 d1 c1 ) t

                                    2          2               2
   + (3 c1 d1 d2 + 6 d1 c1 c2 + 3 c2  + 3 c2 c1  + 2 d1 d3 + d2  + 3 c1 d3

            2       2        2   2        3   4
   + 2 c2 d1  + 3 c1  d2 + c1  d1  + d1 c1 ) t

> chern(3,symm(3,dual(A)));
                                     3
                               - 6 c1  - 30 c1 c2

> segre(2,Hom(wedge(2,A),wedge(2,B)));
                              2                 2
                          3 d1  - 8 c1 d1 + 6 c1  - d2

#-------------------------------------------------------------------------
## Grassmannian of lines in P3:
> 
> grass(2,4,b,all): 
> chi(Gb,Symm(n,Qb));
                             2            3
                            n  + 1 + 1/6 n  + 11/6 n

> chi(Gb,o(n*b1));
                           4        3    23   2
                     1/12 n  + 2/3 n  + ---- n  + 7/3 n + 1
                                         12

> 
## This should be a quadric in P5:
> 
> proj(5,H,all): chi(o(n*H)-o((n-2)*H));
                           4        3    23   2
                     1/12 n  + 2/3 n  + ---- n  + 7/3 n + 1
                                         12

#-------------------------------------------------------------------------
# Lines on a quintic threefold.  This is the top Chern class of the 
# 5th symmetric power of the universal quotient bundle on the Grassmannian
# of lines.
> 
> grass(2,5,c):        # Lines in P^4. 
> B:=symm(5,Qc):       # Qc is the rank 2 quotient bundle, B its 5th 
>                      # symmetric power.
> c6:=chern(rank(B),B):# the 6th Chern class of this rank 6 bundle.
> integral(c6);
                                      2875

#-------------------------------------------------------------------------
# Conics on a quintic threefold. This is the top Chern class of the 
# quotient of the 5th symmetric power of the universal quotient on the
# Grassmannian of 2 planes in P^5 by the subbundle of quintic containing the 
# tautological conic over the moduli space of conics.
> 
> grass(3,5,c):         # 2-planes in P^4.  
> B:=Symm(2,Qc):        # The bundle of conics in the 2-plane. 
> Proj(X,dual(B),z):    # X is the projective bundle of all conics. 
> A:=Symm(5,Qc)-Symm(3,Qc)&@o(-z):  # The rank 11 bundle of quintics 
>                                   # restricted to the universal conic. 
> c11:=chern(rank(A),A):# its top Chern class.
> lowerstar(X,c11):     # push down to G(3,5).
> integral(Gc,%);       # and integrate there.
                                     609250

#-------------------------------------------------------------------------
## Count the number of space conics intersecting 8 given lines
> 
> grass(3,4,d,all):
> Proj(f,dual(symm(2,Qd)),e):
> integral(Gd,lowerstar(f,(2*d1+e)^8));
                                       92

#-------------------------------------------------------------------------
# Conics tangent to 5 plane conics.  Each tangency is a degree 6
# condition on the P^5 of conics; but it contains the degenerate conics with  
# multiplicity 2.
> 
> proj(5,H,all):             # The P^5 of conics.  Tangent bundle needed for 
>                            # blowup.
> proj(2,h,all):             # The P^2 of double lines
> morphism(f,Ph,PH,[H=2*h]): # The Veronese embedding
> blowup(f):                 # Construct Bf, the space of complete conics
> integral((6*H-2*Ef)^5);    # Ef is the exceptional divisor.
                                      3264

#-------------------------------------------------------------------------
# Adjunction formula.  Complete intersection in P^7.
> 
> proj(7,h,tan):             # P^7.  Tangentbundle needed.
> B:=o(n1)+o(n2)+o(n3):      # bundle of triples of forms, of degrees n1,n2,n3.
> bundlesection(Z,B):        # Z is the complete intersection
> cotbun:=-tangentbundle(Z): # the cotangent bundle
> chern(1,cotbun);           # the Chern class of the canonical bundle.
                              - 8 h + n1 + n2 + n3

#-------------------------------------------------------------------------
# Euler characteristic of Horrocks-Mumford bundle
> 
> proj(4,h,tang):            # need tangentbundle for chi
> F:=sheaf(2,[5*h,10*h^2]):  # defines the Horrocks-Mumford bundle
> chi(F&@o(n*h));            # computes chi of its twists
                          4        3   125  2
                    1/12 n  + 5/3 n  + --- n  + 125/6 n + 2
                                        12

#-------------------------------------------------------------------------
# Cohomology of the universal line in P^3.  Done in two ways -  
# LL is the line as a section of a bundle on P3 x G(2,4), whereas Tf is 
# P(universal 2-bundle on G). 
> 
> proj(3,h,all):             # Ph=P^3
> grass(2,4,b,all):          # Gb=G(2,4)
> R:=4-Qb:                   # the universal subbundle on G(2,4)
> productvariety(PG,Ph,Gb,pp,pg): # PG=P3 x G(2,4)
> bundlesection(LL,dual(R)&@o(h)):# universal line
> lis:=NULL: for A in monomials(LL,5) do 
>   if integral(LL,A) <> 0 then lis:=lis,A=integral(LL,A) fi od: 
> lis;
      2  3        3  2        4               2           2          2
    b1  h  = 1, b1  h  = 2, b1  h = 2, b2 b1 h  = 1, b2 b1  h = 1, b2  h = 1

> 
> setvariety(Gb):                  # make G(2,4) currentvariety
> Proj(f,Qb,h,tan):          # P(universal quotient)
> totalspace(f,Gb,tan):
> lis:=NULL: for A in monomials(Tf,5) do 
>   if integral(Tf,A) <> 0 then lis:=lis,A=integral(Tf,A) fi od:
> lis;
      2  3        3  2        4               2           2          2
    b1  h  = 1, b1  h  = 2, b1  h = 2, b2 b1 h  = 1, b2 b1  h = 1, b2  h = 1

> 
> expand(chi(LL,o(m*h+n*b1))-chi(Tf,o(m*h+n*b1))); # chi must be the same
                                       0

#-------------------------------------------------------------------------
# We compute the Hilbert polynomial of a space curve in three ways,
# using the direct image and chi on P^3, and directly on C. We quote
# the name 'i' of the inclusion morphism, in case i has been assigned
# a value earlier in the session.
> 
> proj(3,h,all):
> curve(C,g,p):
> morphism('i',C,Ph,[d*p]):
> lowerstar(i,1);             # class of C in H*(P^3)
                                         2
                                      d h

> lowershriek(i,o(n*d*p)):    # Direct image of o_C(n)
> chi(Ph,%);
                                  1 - g + n d

> oo:=lowershriek(i,1): setvariety(Ph): chi(oo&@o(n*h));
                                  1 - g + n d

> chi(C,i&^*(o(n*h)));
                                  1 - g + n d

#-------------------------------------------------------------------------
# Here we test the compatibility between bundlesection
# and koszul. Use grass(2,5,c) as the ambient space, and
# consider a regular section of the rank-3 bundle symm(2,Qc).
> 
> grass(2,5,c,all):
> bundlesection(Z,symm(2,Qc)):# Z is the zero scheme of a section of symm(2,Qc)
# We may compute the Hilbert polynomial of Z in two ways:
> setvariety(Gc): chi(o(n*c1)&@koszul(symm(2,dual(Qc))));
                                           2        3
                           1 + 11/3 n + 4 n  + 4/3 n

> setvariety(Z): chi(o(n*c1));
                                           2        3
                           1 + 11/3 n + 4 n  + 4/3 n

# The following should be zero:
> difference:=lowershriek(iZ,1)-koszul(dual(symm(2,(Qc))));
 difference :=

           5      2      6   3        6      4      6   2   2         5      3
     32/3 t  c1 c2  - 5 t  c2  + 7/2 t  c2 c1  - 2 t  c2  c1  - 16/3 t  c2 c1

> 
# We check that actually it *is* zero modulo relations:
> 
> grobnerbasis(Gc):
> normalform(Gc,difference);
                                       0

#-------------------------------------------------------------------------
# Riemann-Roch formulas.
# Line bundle O(D) on a threefold.
> 
> variety(X,dim=3,tan=sheaf(3,[-K,c2,c3])): # traditionally, -K is 
>                                           # used instead of c1
> chi(o(D));
                        3          2          2
       integral(X, 1/6 D  - 1/4 K D  + (1/12 K  + 1/12 c2) D - 1/24 K c2)

#-------------------------------------------------------------------------
# number of bitangents to a plane curve
> 
> proj(2,h,all):             # the dual projective plane
> proj(2,j,all):             # the projective plane
> bundlesection(C,o(d*j)):   # define a plane curve of degree d
> morphism(f,C,Ph,[(d-1)*j]):# the Gauss map to the dual plane
> multiplepoint(f,2)/2:      # double points are bitangents or flexes
>                            # correct for flexes.  Flexes can of 
>                            # course be calculated automatically.
> bitangents:=expand(integral(C,%)-(3*d*(d-2)));
                                       4    3        2
                    bitangents := 1/2 d  - d  - 9/2 d  + 9 d

> subs(d=4,%);
                                       28

#-------------------------------------------------------------------------
# blowup 6 points in P2. Cubics through the 6 points give a linear
# system of degree 3 (generically an embedding in P3).
> 
> proj(2,h):
> blowuppoints(Ph,6,e):
> integral(Be,(3*h-e1-e2-e3-e4-e5-e6)^2);
                                       3

#-------------------------------------------------------------------------
# betti numbers of a product of grassmannians
> 
> grass(2,5,a,bas): grass(3,7,b,bas): # make two grassmannians
> productvariety(W,Ga,Gb):            # their product W
> betti(W);                           # betti numbers of W
     [1, 2, 5, 9, 15, 21, 29, 34, 39, 40, 39, 34, 29, 21, 15, 9, 5, 2, 1]

IV. COMMANDS OVERVIEW

SHEAF OBJECTS.

A sheaf object in schubert is a truncated power series (i.e., just a
polynomial) in the reserved variable t. This is the Chern character
polynomial of the sheaf.  There is a global variable DIM, the
dimension, which controls the power of t above which sheaves will be
truncated.  schubert is loaded with DIM=0, so it is important to
redefine DIM (which usually happens automatically when creating
variety objects).  There are three procedures to create sheaf objects
from scratch:

sheaf        - construct coherent sheaf with specified rank and chern 
               classes
bundle       - construct a locally free sheaf with specified rank and
               generic chern classes
o            - construct line bundle with a given first chern class

Procedures to generate new sheaves from existing sheaves:

First a general remark on these: All computations take place
essentially in the Grothendieck ring of the base variety (modulo
numerical equivalence, and with rational coefficients). For locally
free sheaves the answer should have a straightforward interpretation.
For general coherent sheaves, however, the operations must be
understood to be "virtual". For example, tensor(A,B) gives the
alternating sum of the Tor_i(A,B), and Hom(A,B) the alternating sum of
the Ext^i(A,B).  Similar remarks apply to most sheaf operations.

tensor       - tensor product of two sheaves  (infix: A &@ B)
dual         - dual of a sheaf
Hom          - Hom(A,B) sheaf of homomorphisms
End          - End(A) sheaf of endomorphisms = Hom(A,A)
determinant  - the determinant line bundle of a sheaf
wedge        - the exterior powers of a vector bundle
symm         - the symmetric powers of a vector bundle
schurfunctor - the schur symmetrization operator functor
koszul       - alternating sum of exterior powers
adams        - adams operator from K-theory
upperstar    - pullback under morphism         (infix: f&^*(x))
lowershriek  - pushforward under morphism      (infix: f&-!(x))

Note that several of the above allow infix notation.

VARIETY OBJECTS

A variety object is a maple table.  The table can have various entries in it.
This way, a variety is dynamic; new data can be added as needed.

Procedures to generate variety objects:

variety      - construct a general variety object
proj         - construct projective space.
grass        - construct a grassmann variety. grass(k,n,c) constructs
               the Grassmannian of k-dimensional quotients of
               n-dimensional vector space. The universal rank-k
               quotient has chern classes c1,...,ck.
toricvariety - construct a toric variety
wproj        - construct a weighted projective space weighted projective space 
curve        - construct a curve with given genus.
POINT        - not a procedure, but a constant. A variety object
               describing a point.

The table entries in a variety are indexed by strings which consist of
the name of the data present followed by an underscore. Thus for
example X[dimension_] contains the dimension of the variety object X.
Here is a list of most of, or all, the possible entries in a variety
object. To see examples, create some varieties using proj, grass,
Grass, totalspace, toricvariety etc. and look at them with the maple print(X) 
command.

dimension_       - dimension of variety X (an integer)
variables_       - generators of the intersection ring of X (a maple
                   list of names)
degrees_         - the degrees of these generators (a maple list of
                   positive integers)
relations_       - a maple list of relations between the variables_
grelations_      - a grobner basis for the ideal of relations. This is
                   a maple list of the elements in the grobner basis.
order_           - the type of monomial order used (`plex` or `tdeg`)
monomials_       - table of lists of all monomials in the variables_. There
                   is one list of monomials for each codimension
                   (degree). For example, X[monomials_][1] is a list 
                   of the variables of degree 1.
monomialvalues_  - a table where the indices are all monomials of top
                   degree with non-zero integral, and the values are
                   the corresponding integrals
basis_           - a table of lists of monomials in the variables, one 
                   list in each codimension, together constituting an
                   additive basis for the intersection ring N(X).
dualbasis_       - a table of lists of expressions in the variables,
                   one list in each codimension, such that the elements 
                   together constitute a dual basis to X[basis_]
kind_            - a string indicating how the variety was created.
                   For example grassmannbundle_, blowup_,
                   bundlesection_.
point_           - a class with integral=1, thus representing a point.
tangentbundle_   - the tangent bundle of X
toddclass_       - the todd class of X
basevariety_     - image of structure morphism
structuremorphism_ - structure morphism of bundle or blowup object
betti_           - list of betti numbers 
cones_           - list of the cones in a toric variety
StanleyReisner_  - the Stanley-Reisner ideal of a toric variety
edges_           - a matrix whose rows are the edges of the fan of a toric
                   variety
smooth_          - a boolean value, true if the toric variety is smooth
dets_            - the determinants of the cones of a toric variety
edgevariables_   - the names for the generators of the ring of a toric
                   variety
edgevalues_      - the values of the edgevariables in terms of the generators
                   of the Picard group

There are procedures to generate new variety objects from existing ones.  To
describe these, it is convenient to describe morphisms first.

MORPHISM and BUNDLE OBJECTS.

A morphism or bundle is a maple table which, like variety, grows dynamically
as more data is needed. Here are most of the possible entries in a morphism
table f:

source_          - the source variety
target_          - the target variety
dimension_       - the relative dimension
upperstardata_   - sequence of substitutions to be made when computing
                   pullback along f
tangentbundle_   - the virtual relative tangent bundle, or the
                   negative of the virtual normal bundle
toddclass_       - the todd class of f[tangentbundle_]
kind_            - grassmannbundle_, projectivebundle_, blowup_, etc.
lowerstar_       - table for pushing down in Grass and Proj objects.
section_         - class of a section in Grass and Proj objects.
basedimension_   - dimension of base for Grass or Proj object.
fiber_           - variety object corresponding to fiber of Grass or
                   Proj object.

Procedures to generate morphisms:

morphism         - specify an arbitrary morphism between varieties
Proj             - set up a projective bundle. Proj(f,A,c) constructs
                   the bundle of rank-1 quotient bundles of A.
Grass            - set up a Grassmann bundle. Grass(f,k,A,c)
                   constructs the grassmannian of rank-k quotient 
                   bundles of A.
blowup           - blowup along a closed imbedding
productvariety   - construct tensor product of intersection rings
bundlesection    - construct zero variety of regular section of a
                   vector bundle.

Construction of new varieties from old ones:

totalspace       - from Proj or Grass 
blowup           - at the moment no tangent bundle is computed
blowuppoints     - blow up k points on a variety
productvariety   
bundlesection    
insertedge       - create a new toric variety by inserting an edge into
                   a fan

FUNCTIONS ON SHEAVES, VARIETIES, AND MORPHISMS.

rank             - the rank of a sheaf
chern            - the chern class(es) of a sheaf
segre            - segre class(es) of a sheaf. NB! We use the 
                   convention that segre(E)=1/chern(dual(E))
todd             - todd class of a sheaf
schur            - the schur symmetrization operator applied to
                   the chern roots of a sheaf
porteous         - class of degeneration locus of a bundle morphism
porteous2        - same as porteous, slightly different code.
multiplepoint    - the locus of k-fold points of a generically finite
                   morphism
integral         - of a zero-cycle (class of top degree)
chi              - Euler-Poincare characteristic of a coherent sheaf
lowerstar        - pushforward of cycle       ( infix: f&-*(x) )
upperstar        - pullback of cycle or sheaf ( infix: f&^*(x) )
lowershriek      - pushforward of sheaf       ( infix: f&-!(x) )
normalbundle     - retrieve/compute normal bundle of morphism
dimension        - retrieve dimension of variety or morphism
tangentbundle    - retrieve/compute tangent bundle of variety or
                   morphism
betti            - compute betti numbers of a variety


Miscellaneous utilities:

grobnerbasis     - compute grobner basis for ideal of relations
normalform       - standard form modulo a computed grobnerbasis 
integral2        - compute integral using the grobnerbasis approach
division         - divide two classes, with B invertible ( infix: A &/ B )
down             - setvariety to the base of bundle or target of morphism 
whichcone        - finds which cone of a fan a vector lies in
up               - setvariety to the totalspace of bundle or source of morphism
setvariety       - make a variety current 
where            - display information on current variety and DIM
codimension      - of cycle class 
monomials        - of a variety 
verifyduality    - if in doubt.. 


Computation commands:

monomialvalues   - compute table of integrals of 0-cycles 
additivebasis    - compute dual bases 
toddclass        - compute Todd class of variety or morphism


Interface to the inner workings of schubert:

strip            - simplify a class as needed. Default value is 
                   expand.
DIM              - control where computations are truncated


Internal procedures used by schubert:

`schubert/expp`  - convert chern character to chern class
`schubert/logg`  - convert chern class to chern character minus rank
`schubert/lookup`     - read from table, return 0 if entry nonexistant
`schubert/rankblock`  - extract maximal invertible submatrix
`schubert/tosmatrix`  - compute matrix of Kostka numbers
`schubert/unitriangularinverse`  - invert unitriangular matrix
`schubert/maptounitvector` - used to find an integer basis for the lattice
                             of a weighted projective space


V. DESCRIPTION OF ALL COMMANDS

Here are the help texts for all commands in alphabetical order. To see
the help texts for &@, &/, &^*, &-*, &-!, see tensor, division,
upperstar, lowerstar, and lowershriek, respectively.

-------------------------------------------
FUNCTION: adams - the Adams operator of K-theory
   
CALLING SEQUENCE: adams(k,A)
    
PARAMETERS:  k - an expression
             A - a class (polynomial in t)
   
SYNOPSIS: 
- adams(k,A) has the effect of multiplying the degree i component of A
  by k^i.
- In applications, k is often an integer, and A is the Chern character or
  Chern polynomial of a sheaf.
   
EXAMPLES: 
> DIM:=3: b:=bundle(2,c): adams(2,chern(b));
   
                                                 2
                              1 + 2 c1 t + 4 c2 t
   
-------------------------------------------
FUNCTION: additivebasis - compute a pair of dual bases for N*(X)
   
CALLING SEQUENCE: additivebasis(X)
   
PARAMETERS: X - the name of a variety
   
SYNOPSIS:  
- A pair of dual bases are computed and stored in the tables
  X[basis_] and X[dualbasis_]. Each entry is a list. For example
  X[basis_][1] is a list with a basis for Pic(X) as entries.
- If necessary, monomialvalues(X) is called.  So either X[monomialvalues_] 
  must already exist, or X must have a generating set of relations already
  assigned.
- The primary use for these bases is computation of direct images
  for a morphism into X, and for computing betti numbers. 
   
EXAMPLES:
> variety(X,dim=2,var=[H,E],deg=[1,1],rel=[E*H,E^2+H^2],point=H^2):
> additivebasis(X); #X is P^2 blown up at a point.
   
                      a pair of dual bases computed for X
   
> eval(X[basis_]);
   
                                 table([
                                     0 = [1]
                                     1 = [H, E]
                                             2
                                     2 = [- E ]
                                 ])
   
>eval(X[dualbasis_]);
   
                                table([
                                    0 = [1]
                                    1 = [H, - E]
                                            2
                                    2 = [- E ]
                                ])
   
   
SEE ALSO: monomialvalues, verifyduality, betti
   
-------------------------------------------
FUNCTION: betti - compute betti numbers for a variety
   
CALLING SEQUENCES: betti(X)
                   betti(X,n)
   
PARAMETERS: X - the name of a variety
            n - a nonegative integer <= dim(X)
   
SYNOPSIS:  
- The betti numbers in schubert means the dimensions of the graded
  pieces of the numerical intersection ring, so they are the
  numbers of elements in each degree in X[basis_].
- X must have a basis computed for betti to work. 
- With one argument, a list of all betti numbers are returned.
  With two arguments, only the n-th betti number is returned.
- Note that topological betti numbers have twice the index of
  the ones used by schubert.
   
EXAMPLES:
> variety(X,dim=2,var=[H,E],deg=[1,1],rel=[E*H,E^2+H^2],point=H^2):
> additivebasis(X): #X is P^2 blown up at a point.
> betti(X);
   
                                   [1, 2, 1]
   
> betti(X,1);
   
                                       2
SEE ALSO: additivebasis
-------------------------------------------
FUNCTION: blowup - create a blowup
   
CALLING SEQUENCE: blowup(i)
   
PARAMETERS:   i - the name of an inclusion morphism
   
SYNOPSIS: 
- blowup(i) creates the variety B.i, the blowup of i[target_] along
  i[source_].  The table B.i[monomialvalues_] of values of monomials
  on B.i is created.
- The exceptional divisor is called E.i.  p.i is made the structure 
  morphism from B.i to X.
- blowup(i) requires the tangent bundles of i[source_] and i[target_]
  (Warning - no error message is given if these are not supplied),
  the monomialvalues_ table for i[target_], and sufficient data to 
  compute integrals on i[source_] (or these can be left unevaluated).
- B.i is made the currentvariety, and DIM is updated accordingly.
   
EXAMPLES: 
> proj(2,h,all): proj(5,H,all): morphism(f,Ph,PH,[2*h]):
> blowup(f): integral((2*H-Ef)^5); #quadrics through Veronese give
>                                  #a Cremona transformation.
   
                                       1
   
SEE ALSO: morphism, monomialvalues, blowuppoints
   
-------------------------------------------
FUNCTION: blowuppoints - create a blowup of a variety along a set of points
   
CALLING SEQUENCE: blowuppoints(X,k,e)
   
PARAMETERS:   X - the name of a variety
              k - a positive integer
              e - a name
   
SYNOPSIS: 
- blowuppoints(X,k,e) creates the variety B.e, the blowup of X along k points.
  The exceptional divisors are  called e.1..e.k.
- B.e is made the currentvariety, and DIM is updated accordingly.
- A table of non-zero monomialvalues of B.e is constructed.
- If relations are supplied for X, relations are calculated for B.e.
   
EXAMPLES: 
> proj(2,h): blowuppoints(Ph,2,e): integral((2*h-e1-e2)^2);
   
                                       2
   
SEE ALSO: blowup
   
-------------------------------------------
FUNCTION: bundle - creates a bundle with generic Chern classes
   
CALLING SEQUENCES: bundle(rank,name)  
                   bundle(rank,name,variety)
   
PARAMETERS: rank - a non-negative integer
            name - a name
            variety - the name of a variety
   
SYNOPSIS:   
- The call bundle(rank,name) returns the Chern character of a bundle of rank
  equal to rank.  The Chern classes of the bundle are obtained by
  concatenation of the degree of the class with name.  The resulting Chern
  character is truncated in dimension DIM+1.
- The call bundle(rank,name,variety) is as above, except that the result
  is truncated in dimension one more than the dimension of variety.
   
EXAMPLES:   
   
> DIM:=2: b:=bundle(2,c);
   
                                                     2   2
                     b := 2 + c1 t + 1/2 (- 2 c2 + c1 ) t
   
> variety(X,dim=1): DIM:=2: b:=bundle(2,c,X);
   
                                 b := 2 + c1 t
   
SEE ALSO: sheaf, o
   
-------------------------------------------
FUNCTION: bundlesection - create the zero variety of a bundle section
   
CALLING SEQUENCE: bundlesection(Z,F)
   
PARAMETERS:  Z - a name
             F - (the Chern character of) a vector bundle
   
SYNOPSIS: 
- The variety object Z is created corresponding to the zero locus of
  a sufficiently general section of F.  The tangent bundle of Z and the
  monomialvalues_ table of Z are constructed.
- The base space of F must be the currentvariety_ when bundlesection
  is called.  The morphism object i.Z is created to represent the 
  inclusion of Z in the ambient variety.
- Only classes on Z induced from the ambient space are considered.
   
EXAMPLES: 
> proj(3,h): b:=o(4*h): bundlesection(Z,b): up(iZ): integral(h^2);
   
                                       4
   
SEE ALSO: monomialvalues, morphism
   
-------------------------------------------
FUNCTION: chern - the Chern classes of a sheaf
   
CALLING SEQUENCES: chern(A)  
                   chern(p,A)
                   chern(p,q,A)
   
PARAMETERS: A - (the chern character of) a sheaf
            p,q - integers
   
SYNOPSIS:   
- The call chern(A) returns the total Chern class of the sheaf A, truncated
  in dimension DIM+1.
- The call chern(p,A) returns the pth Chern class of A.
- The call chern(p,q,A)  returns a list consisting of all Chern classes of
  between degrees p and q inclusive.
   
EXAMPLES:   
   
> DIM:=4: b:=bundle(4,c): chern(b);
   
                                       2       3       4
                        1 + c1 t + c2 t  + c3 t  + c4 t
   
> chern(2,b);
   
                                       c2
   
> chern(2,4,b);
   
                                  [c2, c3, c4]
   
SEE ALSO: segre
   
-------------------------------------------
FUNCTION: chi - compute Euler-Poincare characteristic
   
CALLING SEQUENCES:
   chi(F)
   chi(X,F)
   
PARAMETERS:
   X - the name of a variety
   F - (The Chern character of a) sheaf
   
SYNOPSIS:   
- Computes the Euler-Poincare characteristic of a sheaf F using
  Riemann-Roch. If X is not given, currentvariety_ is used.
  X[tangentbundle_] must be assigned, toddclass(X) will be called
  if necessary. On the other hand, relations or monomialvalues
  need not be given, so "Riemann-Roch theorems" come out.
   
  Caveat: If the sheaf F is given in a way that involves computation,
          like o(n*h), this is computed with the current value of DIM.
          It is recommended to setvariety(X) before such constructions.
   
EXAMPLES:  
> proj(1,h,all): proj(1,g,all): productvariety(P1xP1,Ph,Pg,p1,p2):
> chi(o(n*h+m*g));
   
                                m + n m + 1 + n
   
> DIM:=2: variety(S,tangentbundle=bundle(2,c)): chi(o(D));
   
                              2                     2
             integral(S, 1/2 D  + 1/2 c1 D + 1/12 c1  + 1/12 c2)
   
SEE ALSO: integral, monomialvalues, toddclass, lowershriek
   
-------------------------------------------
FUNCTION: codimension - the codimension of a class
   
CALLING SEQUENCE: codimension(Y,y)
   
PARAMETERS: Y - the name of a variety
            y - a class on Y
   
SYNOPSIS:   
- codimension(Y,y) returns the codimension of y as a class on Y. 
- If y is not equidimensional, the maximum of the codimensions of the 
  components is returned.
   
EXAMPLES:   
   
> grass(2,4,c): codimension(Gc,c2*c1+2*c1^2);
   
                                       3
   
SEE ALSO:  variety
   
-------------------------------------------
FUNCTION: curve - create a curve
   
CALLING SEQUENCE: curve(C,g,p) 
   
PARAMETERS: C - the name of a curve (variety object)
            g - an integer or a name
            p - a name
   
SYNOPSIS:   
- curve(C,g,p) creates a curve by making C a variety object.  g is the genus,
  and p is the name of the class of a point on the curve.
- The tangentbundle, toddclass, and additive basis are automatically computed.
   
EXAMPLES:   
   
> curve(C,g,p): chi(o(d*p));
   
                                   d + 1 - g
   
  
SEE ALSO:  variety, toddclass, additivebasis
   
-------------------------------------------
FUNCTION: determinant - the determinant line bundle of a sheaf
   
CALLING SEQUENCE:  determinant(A);  
   
PARAMETERS: A - (the Chern character or Chern class of) a sheaf
   
SYNOPSIS:   
- determinant(A) computes the Chern character of the determinant line bundle
  of A,  where A is represented by its Chern character or class.  The result is
  truncated in dimension DIM+1.
   
EXAMPLES:   
   
> DIM:=2: b:=bundle(2,c): determinant(b);
   
                                              2  2
                             1 + c1 t + 1/2 c1  t
SEE ALSO:  o
-------------------------------------------
FUNCTION: dimension - the dimension of a variety
   
CALLING SEQUENCE: dimension(X)
   
PARAMETERS: X - the name of a vareity
   
SYNOPSIS:   
- returns X[dimension_], the dimension of X
   
EXAMPLES:   
   
> grass(3,6,c): dimension(Gc);
  
                                       9
   
SEE ALSO:  variety
   
-------------------------------------------
FUNCTION: division - the quotient of truncated power series in t
   
CALLING SEQUENCES: division(A,B)
                   A &/ B
   
PARAMETERS: A,B - truncated power series in t 
   
SYNOPSIS:   
- division(A,B) gives the quotient of the classes A and B.  B must have 
  non-vanishing constant term.  The result is truncated in dimension DIM+1.
  A &/ B (note infix notation) produces the identical result.
   
EXAMPLES:   
   
> DIM:=3: a:=chern(bundle(2,c)): b:=chern(o(h)): division(a,b);
   
                                       2   2              2       3   3
        1 + (c1 - h) t + (c2 - h c1 + h ) t  + (- h c2 + h  c1 - h ) t
   
> b &/ a;
                                   2   2                           2     3   3
 1 + (h - c1) t + (- c2 - h c1 + c1 ) t  + (- h c2 + 2 c1 c2 + h c1  - c1 ) t
   
SEE ALSO: tensor
   
-------------------------------------------
FUNCTION: down - make the base space of a bundle current
   
CALLING SEQUENCE: down(f)
   
PARAMETERS:  f - the name of a bundle
   
SYNOPSIS:
- down(f) causes the base space f[target_] of the bundle f to become the 
  currentvariety.  DIM is set to the dimension of f[target_], even if 
  f[basedimension_] is assigned but not f[target_].
- down may also be used more generally to make the target of a morphism
  current.
   
EXAMPLES:  
> proj(2,h): Proj(f,1+o(h),c): totalspace(f,Ph): down(f): where();
   
                        currentvariety_ is Ph, DIM is 2
   
SEE ALSO:  up, Grass, Proj
   
-------------------------------------------
FUNCTION: dual - the Chern polynomial or character of a sheaf
   
CALLING SEQUENCE: dual(A);
   
PARAMETERS: A - (the Chern polynomial or character of) a sheaf
   
SYNOPSIS:   
- The call dual(A) returns the dual of the sheaf A.  The result is a Chern
  polynomial or character according to which one A is.
   
EXAMPLES:   
   
> DIM:=4: b:=chern(bundle(2,c)): dual(b);
   
                                               2
                                1 - c1 t + c2 t
-------------------------------------------
FUNCTION: End - the sheaf of endomorphisms of a sheaf
   
CALLING SEQUENCE:  End(A);  
   
PARAMETERS: A - (the Chern character of) a sheaf
   
SYNOPSIS:   
- End(A) computes the Chern character of the sheaf End(A), where A is
  represented by its Chern character.  The result is truncated in dimension
  DIM+1.
   
EXAMPLES:   
   
> DIM:=2: b:=bundle(2,c): End(b);
   
                                        2    2   2
                              4 - 4 c2 t  + t  c1
   
SEE ALSO:  Hom
   
-------------------------------------------
FUNCTION: setvariety - make a given variety the current variety
   
CALLING SEQUENCE: setvariety(X)
   
PARAMETERS: X - the name of a variety
   
SYNOPSIS:   
- X is made the currentvariety_, and DIM is set to X[dimension_].
   
EXAMPLES:   
   
> variety(X,dim=1): variety(Y,dim=2): setvariety(X);
   
                      currentvariety_ is X, DIM is 1
   
SEE ALSO:  variety, DIM
    
-------------------------------------------
FUNCTION: grass - construct a Grassmann variety
   
CALLING SEQUENCES:
   grass(k,r,c)
   grass(k,r,c,all)
   grass(k,r,c,tangentbundle)
   grass(k,r,c,basis)
   
PARAMETERS:  k, r - positive integers
                c - a name
   
SYNOPSIS:
- A variety object G.c is constructed, the Grassmann variety of rank-k
  quotients of an r-dimensional vector space. The universal rank-k 
  quotient bundle on G.c is called Q.c, and its chern classes are
  c1, c2, ..., c.k. The relations are the high segre classes of Q.c,
  segre(i,Q.c) for i=r-k+1..r, and these are also computed.  monomialvalues
  is called.
- The fourth argument determines how much else will be computed.
  tangentbundle will compute the tangentbundle and todd class
  basis will call additivebasis(Gc)
  all will do all the above
- Only the first three letters in the fourth argument are significant.
   
EXAMPLES:  
> grass(2,7,c);
   
                        currentvariety_ is Gc, DIM is 10
   
> integral(c1^10);
   
                                       42
   
SEE ALSO:  variety, proj, Grass, schur
   
-------------------------------------------
FUNCTION: Grass - construct a Grassmann bundle
   
CALLING SEQUENCES:
   Grass(f,k,A,c)
   Grass(f,k,A,c,option)
   
PARAMETERS:  f,c - names
             k - a non-negative integer
             A - (the Chern character of) a sheaf
             option - tan or all
   
SYNOPSIS:
- A bundle object f is constructed, the Grassmann bundle of rank-k
  quotients of the sheaf A, which is represented by its Chern character. 
  The universal rank-k quotient bundle on is called Q.c, and is also stored
  as f[quotientbundle_].  Its Chern classes are c1, c2, ..., c.k.
- A table f[lowerstar_] is created which gives the pushforward of classes in
  the totalspace of the bundle (for any base space).
- Other trivial data attached to k and A are stored in the table for f.
  If tan or all are given, the relative tangent bundle and Todd
  class is computed.
  X is not a variety object.  totalspace must be called to create the variety
  object T.f
   
EXAMPLES:  
> proj(4,h,all): Grass(f,2,Ph[tangentbundle_],c): f[dimension_];
   
                                       4
   
> DIM;
   
                                       8
   
SEE ALSO:  grass, lowerstar, totalspace, Proj
   
-------------------------------------------
FUNCTION: grobnerbasis - compute a grobner basis for the relations
   
CALLING SEQUENCES:
       grobnerbasis(X)
       grobnerbasis(X,order)
   
PARAMETERS:
   X - the name of a variety
   order - 'plex' or 'tdeg' 
   
SYNOPSIS:
- A Grobner basis for the ideal of relations of X is computed and stored
  in X[grelations_]. If 'plex' or 'tdeg' is specified, pure lexicographic
  resp. total degree refined by reverse lex is used. If order is not
  specified, 'tdeg' is used.
   
EXAMPLES:  
> variety(X,dim=2,var=[e,H], rel=[e*H,e^2+H^2],deg=[1,1],poi=H^2):
> grobnerbasis(X,'tdeg');
   
              grobner basis computed with 3 elements
   
SEE ALSO:  normalform, integral2
   
-------------------------------------------
FUNCTION: Hom - the Hom sheaf of two sheaves
   
CALLING SEQUENCE: Hom(A,B)  
   
PARAMETERS: A,B - (Chern characters of) sheaves
   
SYNOPSIS:   
- The call Hom(A,B) returns the Chern character of the sheaf Hom(A,B), where
  A and B are represented by Chern characters.  The result is truncated in
  dimension DIM+1.
   
EXAMPLES:   
   
> proj(3,h,all): Hom(tangentbundle(Ph),o(h));
   
                                       2  2        3  3
                        3 - h t - 1/2 h  t  - 1/6 h  t
   
SEE ALSO:  End   

-------------------------------------------
FUNCTION: insertedge - inserts an edge into the fan of a toric variety

CALLING SEQUENCE: insertedge(Y,X,x,v)
                  insertedge(Y,X,x,v,options)

PARAMETERS:  Y,X,x - names
             v - an integer list
             options - any of the options used to create a toricvariety:
                       Pic,int,bas,tan, or all

SYNOPSIS:
- insertedge(Y,X,x,v) creates a toric variety Y from an existing toric
  variety X by inserting the edge v.  The new edge will be named x.
- The set of cones, the Stanley-Reisner ideal, and the generators for the
  Picard group are updated.
- The options int, bas, tan or all control the computation of the
  intersection numbers, additive basis, and tangentbundle, exactly
  as in the toricvariety procedure.

EXAMPLES:
> wproj(X,x,[1,1,2,2,2]): print(X[edges_]);

                              Variety is singular

                               [  1   2   2   2 ]
                               [                ]
                               [ -1   0   0   0 ]
                               [                ]
                               [  0  -1   0   0 ]
                               [                ]
                               [  0   0  -1   0 ]
                               [                ]
                               [  0   0   0  -1 ]

> insertedge(Y,X,x6,[0,1,1,1]): Y[smooth_];

                                      true

SEE ALSO:  toricvariety, whichcone, wproj, additivebasis, monomialvalues

-------------------------------------------
FUNCTION: integral - compute integral of zero-cycle
   
CALLING SEQUENCES:
   integral(c)
   integral(X,c)
   
PARAMETERS:
   X - the name of a variety
   c - a zero-cycle (expression homogeneous of degree X[dimension_])
   
SYNOPSIS:
- The integral of the zero-cycle c is computed. If X is not given,
  currentvariety_ is used. If X is the total space of a bundle, the
  integral is computed by pushdown followed by integration downstairs.
  Otherwise, if X[monomialvalues_] has not been assigned, the calling sequence
  is returned unevaluated.
   
EXAMPLES:
> variety(P1xP1,dim=2): integral(P1xP1,(g+h)^2);
   
                                                  2
                           integral(P1xP1, (h + g) )
   
> variety(P1xP1,dim=2,var=[h,g],deg=[1,1],rel=[h^2,g^2],poi=g*h): 
> integral(P1xP1,(g+h)^2);
   
                               2
   
SEE ALSO:  integral2, monomialvalues, Grass, Proj, totalspace
   
-------------------------------------------
FUNCTION: integral2 - compute integral (degree of zero-cycle)
   
CALLING SEQUENCE:
   integral2(X,c)
   integral2(c)
   
PARAMETERS:
   X - the name of a variety
   c - a zero-cycle (class of top degree on X)
   
SYNOPSIS:  
- Computes the integral using the normalform/grobnerbasis approach.
  Hence an alternative to integral, which works without using any
  grobner basis.  The currentvariety is used if X is not supplied.
   
EXAMPLES:   
> variety(X,dim=2,var=[e,H], rel=[e*H,e^2+H^2],deg=[1,1], poi=H^2):
> grobnerbasis(X): integral2((2*H-e)^2);
   
                                       3
   
SEE ALSO:  integral, normalform, grobnerbasis
   
-------------------------------------------
FUNCTION: koszul - (the homology of) the koszul complex
   
CALLING SEQUENCE:  koszul(A);  
   
PARAMETERS: A - (the Chern character of) a sheaf
   
SYNOPSIS:   
- koszul(A) computes the alternating sum of the Chern characters of the
  exterior powers of A, which is represented by its Chern character.  The 
  result is truncated in dimension DIM+1.
- koszul(A) computes the Chern character of the homology of the koszul  
  complex on a map from A to the structure sheaf.
   
EXAMPLES:   
   
> proj(3,h): chern(koszul(3*o(-h))); #the Chern class of a point in P^3.
   
                                         3  3
                                  1 + 2 h  t
   
-------------------------------------------
FUNCTION: lowershriek - pushforward in Grothendieck-Riemann-Roch
   
CALLING SEQUENCES: lowershriek(f,A)
                   f &-! A 
   
PARAMETERS: f - the name of a morphism
            A - (the Chern character of) a sheaf
   
SYNOPSIS:   
- lowershriek(f,A) computes f lowershriek of A.  f &-! A (note infix
  notation) is identical.
- The relative Todd class of f is needed.  It is computed and stored in
  f[toddclass_] if necessary.  There must be sufficient information with
  which to compute the relative Todd class.
   
EXAMPLES:   
   
> proj(1,g,all): proj(1,h,all): productvariety(P1xP1,Pg,Ph,p1,p2):
> lowershriek(p1,o(n*h));
   
                                     1 + n
   
> p1&-!(o(n*g));
   
                                   1 + n g t
  
SEE ALSO:  morphism, lowerstar, Grass, Proj, toddclass, chi
   
-------------------------------------------
FUNCTION: lowerstar - pushforward by a morphism
   
CALLING SEQUENCES: lowerstar(f,y)
                   f &-* y 
   
PARAMETERS: f - the name of a morphism
            y - a polynomial (class on the target of f)
   
SYNOPSIS:   
- lowerstar(f,y) computes the pushforward of y via f.  f &-* y (note
  infix notation) is identical.
- If f is a bundle morphism, then lowerstar looks up the table f[lowerstar_]
  which was created when forming the bundle via Grass or Proj.
- Otherwise, duality is used to infer the result from the pullback map using
  an additive basis for the target of f.   additivebasis is called if
  necessary.
   
EXAMPLES:   
   
> proj(1,g): proj(1,h): productvariety(P1xP1,Pg,Ph,p1,p2):
> lowerstar(p1,(g+h)^2);
   
                                      2 g
   
> proj(4,h,all): Proj(X,Ph[tangentbundle_],z): X&-*((z+h)^4);
   
                                      9 h
  
SEE ALSO:  morphism, additivebasis, Grass, Proj, Symm
   
-------------------------------------------
FUNCTION: monomials - list all monomials in the variables
    
CALLING SEQUENCE:
    monomials(X)
    monomials(X,n)
    monomials(n,vars,degs)
   
PARAMETERS:
    X - the name of a variety, or a Grassmannian or projective bundle
    n - non-negative integer
    vars - list of variables
    degs - list of degrees
    
SYNOPSIS: 
- monomials(X,n) computes all monomials in the variables of X up to
  weighted degree n (or the dimension of X, if that is larger or if 
  n is not specified). These are stored in a table X[monomials_]. 
- The value returned by monomials(X,n) is X[monomials_][n]. 
- The value returned by monomials(X) is X[monomials_].
- monomials(n,vars,degs) returns a list of all monomials of weighted
  degree n in the variables vars with the weights degs.
    
EXAMPLES:
> variety(P1xP1,dim=2,var=[h,g],degs=[1,1]): monomials(P1xP1,2);
   
                                   2        2
                                 [h , h g, g ]
   
> monomials(3,[c1,c2],[1,2]);
                                     3
                                  [c1 , c1 c2]
   
SEE ALSO:  monomialvalues
   
-------------------------------------------
FUNCTION: monomialvalues - compute integrals of top degree monomials
   
CALLING SEQUENCE: monomialvalues(X)
   
PARAMETERS:  X - the name of a variety
   
SYNOPSIS:  
- The integrals of all monomials of degree the dimension of X are
  computed and stored in a table X[monomialvalues_]. X needs to have
  assigned a generating set of relations. 
- If X[point_] has not been assigned, the values obtained are only determined
  up to an (unknown) common scalar. It may be possible to correct this later
  if one comes up with a different way to compute the class of a point, for
  example if the topological Euler characteristic is known the Gauss-Bonnet
  formula may be used.
   
EXAMPLES:  
> variety(X,dim=2,var=[h,e],deg=[1,1],poi=h^2): X[relations_]:=[h^2+e^2,h*e]:
> monomialvalues(X);
   
             computed integral of all 3 monomials of top degree
   
> eval(X[monomialvalues_]);
   
                                  table([
                                      h e = 0
                                       2
                                      e  = -1
                                       2
                                      h  = 1
                                  ])
   
SEE ALSO:  monomials, integral
   
-------------------------------------------
FUNCTION: morphism - construct a morphism object
   
CALLING SEQUENCES: morphism(f,X,Y)
                   morphism(f,X,Y,sb)
   
PARAMETERS: X,Y - names of a varieties
            sb - a list of substitutions.  Can be either of the form
                 [s1,...,sn], where n is the number of variables of Y, or
                 [v1=s1,...,vk=sk], and the vi are variables of Y.
   
SYNOPSIS:   
- morphism(f,X,Y,sb) creates a table for the morphism object f.  f[source_]
  is set to X, f[target_] is set to Y, and f[dimension_] is set to the 
  relative dimension X[dimension_]-Y[dimension_].  The substitutions become
  f[upperstardata_], if substitutions are given.  The substitions are just
  the pullbacks to X of the generating classes on Y.
- If the substitution list is given in the form [s1,...,sn], the substitutions
  are v1=s1,...,vn=sn, where the vi are the variables of Y in the order given
  in Y[variables_].
   
EXAMPLES:   
   
> proj(2,h): proj(5,H): morphism(f,Ph,PH,[2*h]); #the Veronese map.
   
                                       f
   
> f[upperstardata_];
   
                                    H = 2 h
   
SEE ALSO:  variety, lowerstar, lowershriek, upperstar
   
-------------------------------------------
FUNCTION: multiplepoint - compute the multiple point locus of a morphism
   
CALLING SEQUENCE:   multiplepoint(f,k)
   
PARAMETERS:
   f - the name of a morphism
   k - a non-negative integer (currently between 1 and 3)
   
SYNOPSIS:  
- Computes the class of the k-fold point locus of the morphism f (as a class
  in f[source_]).  The normal bundle of f must be computable by the 
  normalbundle procedure, as well as f^* and f-*. To get the class of the
  image of the k-fold point locus, push forward and divide by k! .
   
EXAMPLES:   
> curve(C,g,p): proj(2,h,all): morphism(f,C,Ph,[d*p]):
> integral(C,multiplepoint(f,2));
   
                                2
                               d  + 2 - 2 g - 3 d
   
SEE ALSO:  normalbundle, lowerstar
   
-------------------------------------------
FUNCTION: normalbundle - the normal bundle of a morphism
   
CALLING SEQUENCE: normalbundle(f)
   
PARAMETERS: f - the name of a morphism
   
SYNOPSIS:   
- normalbundle(f) returns the Chern character of the virtual normal bundle of 
  the morphism f.   Its negative is stored as f[tangentbundle_] if this has
  not yet been computed.
- If f is a bundle morphism, then f[tangentbundle_] is the relative tangent
  bundle, and may be created by the bundle procedures Grass and Proj.
- If f[tangentbundle_] is not assigned, then the tangent bundle of the source
  and target of f is used.  These are used in unevaluated form if they have not
  been assigned.  Warning: in this form, the tangent bundle of the target will
  not be pulled back to the source.
   
EXAMPLES:   
   
> proj(2,h): proj(5,H): morphism(f,Ph,PH,[2*h]): normalbundle(f);
   
                   - Ph[tangentbundle_] + PH[tangentbundle_]
   
> proj(2,h,all): proj(5,H,all): morphism(f,Ph,PH,[2*h]): normalbundle(f);
   
                                               2  2
                             3 + 9 h t + 21/2 h  t
  
SEE ALSO:  morphism, Grass, Proj, upperstar, tangentbundle
   
-------------------------------------------
FUNCTION: normalform - normal form with respect to a grobner basis
   
CALLING SEQUENCE:
   normalform(c)
   normalform(X,c)
   
PARAMETERS:
   X - the name of a variety
   c - an expression (cycle class or polynomial in t)
   
SYNOPSIS:  
- The expression c is reduced to its normal form modulo the list
  X[grelations_] (presumably a grobner basis). If X is not given,
  currentvariety_ is used. (This can be exploited for a subset of 
  the relations, if X[grelations_] is assigned manually.)
   
EXAMPLES: 
> variety(X,dim=2,var=[e,H], rel=[e*H,e^2+H^2],deg=[1,1],point=H^2):
> grobnerbasis(X): normalform((H+2*e)^2);
   
                                          2
                                     - 3 H
   
SEE ALSO:  variety, grobnerbasis
   
-------------------------------------------
FUNCTION: o - the Chern character of the line bundle associated to a divisor
   
CALLING SEQUENCES: o(d)  
                   o(d,X)
   
PARAMETERS: d - a degree 1 class (a divisor)
            X - the name of a variety
   
SYNOPSIS:   
- The call o(d) returns the Chern polynomial of the line bundle O(d)
  associated to the divisor d.  The result is truncated in dimension DIM+1.
- The call o(d,X) is as above, except that the result
  is truncated in dimension one more than the dimension of variety.
   
EXAMPLES:   
   
> DIM:=2: o(d);
   
                                             2  2
                              1 + d t + 1/2 d  t
   
> variety(X,dim=1): DIM:=2: o(d,X);
   
                                    1 + d t
   
SEE ALSO: bundle
   
-------------------------------------------
FUNCTION: POINT - a point
   
CALLING SEQUENCES: POINT 
   
PARAMETERS: none
   
SYNOPSIS:   
- POINT is a table which gives the variety object corresponding to a point.
   
EXAMPLES:   
   
> Grass(X,2,4,c): integral(X,c1^4);
   
Error, (in additivebasis) Usage: additivebasis(variety)
   
> totalspace(X,POINT): integral(TX,c1^4);
   
                                       2
   
SEE ALSO:  variety, totalspace
   
-------------------------------------------
FUNCTION: porteous - Porteous' formula
   
CALLING SEQUENCE: porteous(A,B,k)
   
PARAMETERS: A ,B - (the Chern characters of) sheaves
            k - an integer
   
SYNOPSIS:   
- porteous(A,B,k) returns the class of the locus over which a general morphism
  f from A to B has rank at most k, that is, the locus of vanishing of the
  (k+1) by (k+1) minors of f.
- It is computed by expanding the determinant giving Porteous' formula.
- porteous2(A,B,k) computes the same thing similarly using the package SF
  written by John Stembridge.
   
EXAMPLES:   
   
> DIM:=4: a:=bundle(2,c): b:=bundle(3,d): porteous(a,b,1);
   
                                        2
                            - d1 c1 + c1  + d2 - c2
   
SEE ALSO:  porteous2
   
-------------------------------------------
FUNCTION: porteous2 - Porteous' formula
   
CALLING SEQUENCE: porteous2(A,B,k)
   
PARAMETERS: A ,B - (the Chern characters of) sheaves
            k - an integer
   
SYNOPSIS:   
- porteous(A,B,k) returns the class of the locus over which a general morphism
  f from A to B has rank at most k, that is, the locus of vanishing of the
  (k+1) by (k+1) minors of f.
- It is computed via a schur function.  This uses the package SF written by 
  John Stembridge, as so SF must be accessible to Maple.
- porteous(A,B,k) computes the same thing similarly, without SF.
   
EXAMPLES:   
   
> DIM:=4: a:=bundle(2,c): b:=bundle(3,d): porteous2(a,b,1);
   
                                        2
                            - d1 c1 + c1  + d2 - c2
   
SEE ALSO:  porteous, schur
   
-------------------------------------------
FUNCTION: productvariety - create the product of two varieties
   
CALLING SEQUENCES:  productvariety(W,X,Y)
                    productvariety(W,X,Y,pr1,pr2)
   
PARAMETERS:   W,pr1,pr2 - names
              X,Y - names of varieties
   
SYNOPSIS: 
- The variety object W is created corresponding to the product of X and Y.
- If X[monomialvalues_] and Y[monomialvalues_] are known, then 
  W[monomialvalues_] is calculated.  Similarly for the table entries point_,
  tangentbundle_, basis_, and dualbasis_.
- The presence of the last two arguments causes the morphism objects pr1 and 
  pr2 to be created, corresponding to the projections onto X and Y, 
  respectively.
   
EXAMPLES: 
> proj(2,h): grass(2,4,c): productvariety(X,Ph,Gc):
> integral((h+c1)^6);
   
                                       30
   
SEE ALSO: variety, morphism
   
-------------------------------------------
FUNCTION: proj - construct projective space
   
CALLING SEQUENCES:
   proj(n,h)
   proj(n,h,option)
   
PARAMETERS: n - a non-negative integer
            h - a name
            option - one of tan, bas, or all
   
SYNOPSIS: 
 - A variety object P.h is constructed, projective n-dimensional space.
   The hyperplane class will be called h. monomialvalues is called.
 - tan results in the computation of the tangent bundle and Todd class.
 - bas results in the computation of additive bases.
 - all results in all of the above being computed.
   
EXAMPLES:  
> proj(2,g,all);
   
                        currentvariety_ is Pg, DIM is 2
   
> chern(2,Pg[tangentbundle_]);
   
                                         2
                                      3 g
   
SEE ALSO:  variety, Proj
   
-------------------------------------------
FUNCTION: Proj - construct a projective bundle
   
CALLING SEQUENCES:
   Proj(f,A,c)
   Proj(f,A,c,option)
   
PARAMETERS:  f,c - names
             A - (the Chern character of) a sheaf
             option - tan or all
   
SYNOPSIS:
- A bundle object f is constructed, the projective bundle of rank 1
  quotients of the sheaf A, which is represented by its Chern character. 
  c is the first Chern class of the tautological quotient line bundle.
- A table f[lowerstar_] is created which gives the pushforward of classes in
  the totalspace of the bundle (for any base space).
- X, if given, is the name of the base variety.  The base is assumed to have
  dimension DIM if X is not specified.  DIM is updated to the dimension
  rank(A)-1+dimension of base = dimension of total space in any case.
  If tan or all are given, the relative tangent bundle and Todd
  class is computed.
  X is not a variety object.  totalspace must be called to create the variety
  object T.f
   
EXAMPLES:  
> proj(2,h,all): Proj(f,tangentbundle(Ph),c): eval(f[lowerstar_]);
   
                                 table([
                                      3      2
                                     c  = 6 h
                                     c = 1
                                      2
                                     c  = 3 h
                                 ])
   
SEE ALSO:  grass, lowerstar, totalspace, Proj
   
-------------------------------------------
FUNCTION: rank - the rank of a sheaf
   
CALLING SEQUENCE: rank(A)
   
PARAMETERS: A - (the Chern character of) a sheaf
   
SYNOPSIS:   
- rank(A) returns the rank of the sheaf A, where A is represented by its
  Chern character.
   
EXAMPLES:   
   
> DIM:=4: b:=bundle(2,c): s3b:=symm(3,b): rank(s3b);
   
                                       4
   
SEE ALSO:  chern
-------------------------------------------
FUNCTION: schur - the schur function in the Chern classes of a sheaf
   
CALLING SEQUENCES:  schur(partition,A)  
                    schur(partition,partition2,A)
   
PARAMETERS: A - (the Chern character of) a sheaf
            partition,partition2 - a list of integers
   
SYNOPSIS:   
- schur(partition,A) computes the schur function in the Chern classes of the
  sheaf A, where A is represented by its Chern character.
- schur(partition,partition,A) computes the skew schur function.
- In either case, the package SF written by John Stembridge is called, and so
  SF must be accessible to Maple.
- The schubert2 cycles on a Grassmannian can be calculated by applying schur to
  the universal quotient bundle.
   
EXAMPLES:   
   
> grass(3,5,c): sigma21:=schur([2,1],Qc);
   
                             sigma21 := c1 c2 - c3
   
SEE ALSO:  schurfunctor, schurfunctor2, porteous2
   
-------------------------------------------
FUNCTION: schurfunctor - a Schur functor applied to a sheaf
   
CALLING SEQUENCE: schurfunctor(partition,A)
                  schurfunctor(partition,partition2,A)
   
PARAMETERS: partition, partition2 - a list of integers (partitions)
            A - (the Chern character of) a sheaf
   
SYNOPSIS:   
- schurfunctor(partition,A) gives the Chern character of the corresponding
  Schur functor applied to the sheaf A, where A is represented by its
  Chern character.
- schurfunctor(partition,partition2,A) does the analogous thing with the
  skew Schur functor.
- the package SF written by John Stembridge is called in either case, and so
  must be accessible to Maple.
- schurfunctor2(partition,A) computes the same thing as
  schurfunctor(partition,A) by a different method.
   
EXAMPLES:   
   
> DIM:=4: b:=bundle(2,c): schurfunctor([2],b)-symm(2,b);
   
                                       0
   
> DIM:=4: b:=bundle(3,c): schurfunctor([1,1],b)-wedge(2,b);
   
                                       0
   
SEE ALSO:  schur, schurfunctor2
   
-------------------------------------------
FUNCTION: schurfunctor2 - a Schur functor applied to a sheaf
   
CALLING SEQUENCE: schurfunctor2(partition,A)
   
PARAMETERS: partition - a list of integers (a partition)
            A - (the Chern character of) a sheaf
   
SYNOPSIS:   
- schurfunctor2(partition,A) gives the Chern character of the corresponding
  Schur functor applied to the sheaf A, where A is represented by its
  Chern character.
- schurfunctor2 is calculated via Pieri's formula. 
- A remember table is created.
- schurfunctor(partition,A) computes the same thing as
  schurfunctor2(partition,A) by a different method.
   
EXAMPLES:   
   
> DIM:=4: b:=bundle(2,c): schurfunctor2([2],b)-symm(2,b);
   
                                       0
   
> DIM:=4: b:=bundle(3,c): schurfunctor2([1,1],b)-wedge(2,b);
   
                                       0
   
SEE ALSO:  schur, schurfunctor2
   
-------------------------------------------
FUNCTION: segre - the Segre classes of a sheaf
   
CALLING SEQUENCES: segre(A)
                   segre(p,A)
                   segre(p,q,A)
   
PARAMETERS: A - the name of a sheaf
            p,q - integers
   
SYNOPSIS:   
- The call segre(A) returns the total Segre class of the sheaf A, truncated
  in dimension DIM+1.
- The call chern(p,A) returns the pth Segre class of A.
- The call chern(p,q,A)  returns a list consisting of all Segre classes of
  between degrees p and q inclusive.
- NB: segre(A)=1/chern(dual(A)), so that in particular s1 = c1.
  This differs from other standard conventions, e.g. Fulton's book
  "Intersection Theory".
   
EXAMPLES:   
   
> DIM:=3: b:=bundle(3,c): segre(b);
   
                                   2   2                     3   3
              1 + c1 t + (- c2 + c1 ) t  + (c3 - 2 c1 c2 + c1 ) t
   
> segre(2,b);
   
                                            2
                                   - c2 + c1
   
> segre(2,3,b);
   
                                  2                   3
                        [- c2 + c1 , c3 - 2 c1 c2 + c1 ]
   
SEE ALSO: chern
   
-------------------------------------------
FUNCTION: sheaf - creates a sheaf object with given chern classes
   
CALLING SEQUENCES: sheaf(rank,classes)  
                   sheaf(rank,classes,variety)
   
PARAMETERS: rank - a non-negative integer
            classes - a list
            variety - the name of a variety object
   
SYNOPSIS:   
- The call sheaf(rank,classes) returns the Chern character of a sheaf of rank
  equal to rank, with Chern classes c.i determined by [c.1..c.k]=classes.
  All unspecified Chern classes are zero.  The resulting Chern character is
  truncated in dimension DIM + 1
- The call sheaf(rank,classes,variety) is as above, except that the result
  is truncated in dimension one more than the dimension of variety.
   
EXAMPLES:   
   
> DIM:=2: b:=sheaf(2,[c1,c2]);
   
                                                     2   2
                     b := 2 + c1 t + 1/2 (- 2 c2 + c1 ) t
   
> variety(X,dim=1): DIM:=2: b:=sheaf(2,[c1,c2],X);
   
                                 b := 2 + c1 t
   
SEE ALSO: bundle
   
-------------------------------------------
FUNCTION: strip - simplify a sheaf as necessary
   
CALLING SEQUENCES: strip(A)
   
PARAMETERS: A - an expression
   
SYNOPSIS:   
- strip is used to simplify a class; for example, to effect 
  simplifications implied by relations in the Chow ring.
- strip is intended to be redefined by the user if needed.  The default is 
  strip = expand.  
- strip is called by many procedures which manipulate sheaf objects, but
  not all.
   
EXAMPLES:   
   
> strip((x+y)^2);
   
                                 2            2
                                x  + 2 x y + y
   
> strip:=proc(x) subs(seq(a^i=0,i=2..10),expand(x)) end: DIM:=5: 
> o(a)&@o(b);
   
                        2  2    2            3  3        3    2         4  4
   1 + b t + a t + 1/2 b  t  + t  a b + 1/6 b  t  + 1/2 t  a b  + 1/24 b  t
   
               4    3          5  5         5    4
        + 1/6 t  a b  + 1/120 b  t  + 1/24 t  a b
   
-------------------------------------------
FUNCTION: symm - the symmetric power of a sheaf
   
CALLING SEQUENCE:  symm(p,A);  
   
PARAMETERS: p - an integer
            A - (the Chern character of) a sheaf
   
SYNOPSIS:   
- symm(p,A) returns the Chern character of the pth symmetric power of the sheaf
  A, where A is represented by its Chern character.  The result is truncated
  in dimension DIM+1.
- symm(p,A) is usually faster than Symm(p,A) if p is small.
- symm creates a remember table.
- symm(p,A) proceeds by iterating p.
   
EXAMPLES:   
   
> DIM:=2: b:=bundle(2,c): symm(3,b);
   
                                            2       2  2
                        4 + 6 c1 t - 10 c2 t  + 7 c1  t
   
SEE ALSO:  Symm, schurfunctor, schurfunctor2, wedge
   
-------------------------------------------
FUNCTION: Symm - the pth symmetric power of a sheaf
   
CALLING SEQUENCE: Symm(p,A)
   
PARAMETERS: p - an integer or a name
            A - (the Chern character of) a sheaf
   
SYNOPSIS:   
- Symm(p,A) returns the Chern character of the pth symmetric power of the sheaf
  A, where A is represented by its Chern character.  The result is truncated
  in dimension DIM+1.
- Symm(p,A) is usually faster than symm(p,A) if p is large.
- Symm(p,A) creates the variable SYMM_[A].
- Symm works by pushing down multiples of the tautological bundle in an 
  associated projective bundle.
   
EXAMPLES:   
   
> DIM:=2: b:=bundle(2,c): Symm(n,b);
   
                            2     2        2                  2        2  2   2
 1 + 1/2 t n c1 + n + 1/12 t  n c1  - 1/3 t  n c2 + 1/2 t c1 n  + 1/4 t  n  c1
   
             2  2           2  3           2  3   2
      - 1/2 t  n  c2 - 1/6 t  n  c2 + 1/6 t  n  c1
   
SEE ALSO:  symm, schurfunctor, schurfunctor2, wedge, lowerstar, Proj
   
-------------------------------------------
FUNCTION: tangentbundle - the tangent bundle of a variety
   
CALLING SEQUENCE: tangentbundle(X)
   
PARAMETERS: X - the name of a vareity
   
SYNOPSIS:   
- returns X[tangentbundle_], the Chern character of the tangentbundle of X
- calculates the tangent bundle and Todd class of X as well, if X is a
  projective space, grassmannian, projective bundle, or grassmann bundle.
   
EXAMPLES:   
   
> proj(2,h,all): tangentbundle(Ph);
  
                                              2  2
                             2 + 3 h t + 3/2 h  t
   
SEE ALSO:  variety, normalbundle
   
-------------------------------------------
FUNCTION: tensor - the tensor product of two sheaves
   
CALLING SEQUENCES: tensor(A,B);  or
                   A &@ B;
   
PARAMETERS: A,B - (the Chern characters of) sheaves
   
SYNOPSIS:   
- The call tensor(A,B) returns the Chern character of the tensor product of A
  and B.  The result is truncated in dimension DIM+1.  A &@ B (note infix
  notation) produces the identical result.
- Tensor may also be used to multiply two classes.
   
EXAMPLES:   
   
> DIM:=2: b:=bundle(2,c): tensor(b,o(d));
   
                                2  2    2            2        2   2
            2 + 2 d t + c1 t + d  t  + t  c1 d - c2 t  + 1/2 t  c1
   
SEE ALSO: division
   
-------------------------------------------
FUNCTION: todd - the Todd class of a sheaf
   
CALLING SEQUENCE: todd(A)
   
PARAMETERS: A - (the Chern character of) a sheaf
   
SYNOPSIS:   
- todd(A) returns the Todd class of the sheaf A, truncated in dimension DIM+1.
  A is represented by its Chern character.
   
EXAMPLES:   
   
> DIM:=2: b:=bundle(2,c): todd(b);
   
                                            2             2
                     1 + 1/2 c1 t + (1/12 c1  + 1/12 c2) t
   
SEE ALSO: toddclass, chi
    
-------------------------------------------
FUNCTION: toddclass - the Todd class of a variety or bundle
   
CALLING SEQUENCE:  toddclass(X)  
   
PARAMETERS: X - the name of a variety, or a Grassmannian or projective bundle
   
SYNOPSIS:   
- The Todd class is computed and stored in X[toddclass_]. X is made
  the currentvariety_.
- If X is the structure morphism of a bundle, then the relative Todd class
  is computed.
   
EXAMPLES:   
   
> DIM:=2: variety(X,dim=2,tan=bundle(2,c)): toddclass(X);
   
                            toddclass computed for X
   
> X[toddclass_];
                                            2             2
                     1 + 1/2 c1 t + (1/12 c1  + 1/12 c2) t
    
SEE ALSO:  todd, chi
   
-------------------------------------------

FUNCTION: toricvariety - construct a toric variety
   
CALLING SEQUENCES:
 toricvariety(X,x,edges,<A1,A2,A3,A4,A5,A6>)
   
PARAMETERS: X - a name
            x - a name or a list of names
            edges - a integer valued matrix or list of lists
            A1,A2,A3,A4,A5,A6 are options, each one of the following types
   
            amp=list  an ample Weil divisor given in terms of a vector of
                      coefficients of the basic divisors corresponding to 
                      edges
            sri=list  a list of equations of the Stanley-Reisner ideal
            con=list  a list of lists, each of which contains the generators
                      of the cones in the fan.
            Pic=list  a list of linearly independent elements in 
                      for the group of Q-divisors, in the form
                      [name1=x.i,name2=x.j,...], where name1,name2,..
                      are user-specified names and x.i,... are the variables
                      associated to the generators.
            opt       if present, its first three characters should be
                      'int', 'bas', 'tan', or 'all'.
   
            For each of the first four types, the full argument may be
            shortened to only the right hand side of the equation. 
            At least one of the amp, sri, or con arguments is needed.
            Other than that, any number can be specified, and
            in any order.
   
SYNOPSIS:
- A variety object X is constructed, the toric variety associated to the
  given data.  The primitive generators of the edges of the fan 
  (assumed to be simplicial) are given by the variable edges, either as a
  list of lists or as a matrix (one row for each edge).
  The names of the divisors corresponding to the edges will be
  automatically constructed from the name x as x.1,x.2,...
  or else given explicitly if x is a list of names.
- A list of cones in the fan is stored in X[cones_] as a list of lists
  each list consisting of integers associated to the edges of a cone.
- The Stanley Reisner ideal is stored as a list of monomials in
  X[StanleyReisner_]
- The generators for the Picard group will be chosen automatically unless
  the user specifies the generators using the Pic option.  In any case,
  the divisors corresponding to the edges are expressed in terms of the
  relevant basis for the Picard group, and are stored in the list
  X[edgevalues_].
- tan results in the computation of the tangent bundle and Todd class.
- bas results in the computation of additive bases for the int. ring.
- int results in the computation of the intersection ring.
- all results in all of the above being computed.
   
EXAMPLES:
> toricvariety(P1xP1,x,[[1,0],[0,1],[-1,0],[0,-1]],amp=[1,1,0,0], 
> Pic=[h1=x1,h2=x2],all);
   
                       currentvariety_ is P1xP1, DIM is 2
   
> P1xP1[edgevalues_];
   
                                [h1, h2, h1, h2]
   
> P1xP1[cones_];
   
                        [[1, 2], [1, 4], [2, 3], [3, 4]]
   
>  toricvariety(P1xP1,x,[[1,0],[0,1],[-1,0],[0,-1]],
> con=[[1,2],[2,3],[3,4],[4,1]],all);
   
                       currentvariety_ is P1xP1, DIM is 2
   
> P1xP1[edgevalues_];
   
                                [x3, x4, x3, x4]
   
> P1xP1[StanleyReisner_];
   
                                 [x1 x3, x2 x4]
   
> toricvariety(P1xP1,x,[[1,0],[0,1],[-1,0],[0,-1]],
> sri=[x1*x3,x2*x4]);
   
                       currentvariety_ is P1xP1, DIM is 2
   
SEE ALSO:  variety, monomialvalues, additivebasis, wproj, whichcone
           insertedge
   
-------------------------------------------
FUNCTION: totalspace - create the total space of a bundle
   
CALLING SEQUENCE: totalspace(f,X,option)
    
PARAMETERS: f - the name of a bundle
            X - the name of a variety
            option - tan or bas or all
   
SYNOPSIS:
- totalspace(f,X) creates the variety object T.f, the totalspace of
  the bundle f with base space X.  T.f is made the currentvariety, 
  and DIM is set to the dimension of T.f.  integral works on T.f if
  it works on X.
- tan results in the calculation of the tangent bundle and Todd class
  of T.f.
- bas results in the calculation of an additive basis for T.f.  X must
  have its additive basis and dual basis assigned.  totalspace
  uses this to construct T.f[basis_] and T.f[dualbasis_].
- all does all of the above.
    
EXAMPLES: 
> grass(2,4,c): Proj(X,Qc,z): totalspace(X,Gc): integral(z^5);
    
                                     0
   
SEE ALSO: Grass, Proj, additivebasis
   
-------------------------------------------
FUNCTION: up - make the total space of a bundle current
   
CALLING SEQUENCE: up(f)
   
PARAMETERS:  f - the name of a bundle
   
SYNOPSIS:
- up(f) causes the total space f[source_] of the bundle f to become the 
  currentvariety.  DIM is set to the dimension of f[source_].  DIM is updated
  if f[basedimension_] has been assigned, even if f[source_] has not been
  assigned.
- up may also be used more generally to make the source of a morphism current.
   
EXAMPLES:  
> proj(2,h): Proj(f,1+o(h),c): totalspace(f,Ph): setvariety(Ph): up(f): where();
   
                        currentvariety_ is Tf, DIM is 3
   
SEE ALSO:  down, Grass, Proj
   
-------------------------------------------
FUNCTION: upperstar - pullback by a morphism
   
CALLING SEQUENCES: upperstar(f,y)
                   f &^* y 
   
PARAMETERS: f - the name of a morphism
            y - a polynomial (class on the target of f)
   
SYNOPSIS:   
- upperstar(f,y) computes the pullback of y to x via f.  f &^* y (note
 infix notation) is identical.
- y may be either a sheaf object on the target of f (truncated power series in
  t), or a homogeneous class on the target of f.
   
EXAMPLES:   
   
> curve(C,3,p): proj(3,h,all): morphism(f,C,Ph,[6*p]): 
> upperstar(f,Ph[tangentbundle_]);
   
                                   3 + 24 p t
   
f&^*(5*h);
   
                                      30 p
   
SEE ALSO:  morphism, normalbundle
   
-------------------------------------------
FUNCTION: variety - construct a variety object
   
CALLING SEQUENCE: variety(X,<options>)
   
PARAMETERS: X - (an expression that evaluates to) a name
   
  Options are mainly of the form option=value, they are separated by
  commas and may come in any order, except bases or all,
  which must come at the end.
  Options are:
    dimension=(a non-negative integer)
    variables=(a list of names)
    degrees=(a list of positive integers) 
    relations=(a list of relations)
    point=(the class of a point)
    tangentbundle=(sheaf object)
    bases or all
  Only the first three letters in the option names are significant.
    
SYNOPSIS: 
- A table named X is created, with entries corresponding to the given
  options. If the dimension option is not given, the dimension of X
  is set to the current value of DIM.
- The variable currentvariety_ is set to X, and DIM is set accordingly.
- If the relations option is given, monomialvalues is called.
  bases or all results in the calling of additivebasis.
   
EXAMPLES: 
> variety(P1xP1,dim=2,var=[h,g],degs=[1,1],rels=[h^2,g^2],point=h*g);
   
                    currentvariety_ is P1xP1, DIM is 2
   
SEE ALSO:  proj, grass, curve, setvariety, monomialvalues, additivebasis
   
-------------------------------------------
FUNCTION: verifyduality - utility for checking that dual bases are correct
   
CALLING SEQUENCE: verifyduality(X)
   
PARAMETERS: X - the name of a variety
   
SYNOPSIS:   
- verifyduality(X) multiplies the classes of complementary degrees and
  integrates the resulting zero cycles, printing the results.  Each printed
  matrix will be an identity matrix if the bases are indeed dual.
- X[basis_] and X[dualbasis_] are needed.  This utility should not be
  needed if X[basis_] and X[dualbasis_] were created using additivebasis.
   
EXAMPLES:   
   
> grass(2,4,c,basis): verifyduality(Gc);
   
                                 det .[ 1 ] = 1
   
                                 det .[ 1 ] = 1
   
                                    [ 1  0 ]
                               det .[      ] = 1
                                    [ 0  1 ]
  
                                 det .[ 1 ] = 1
   
                                 det .[ 1 ] = 1
   
SEE ALSO:  additivebasis, integral
   
-------------------------------------------
FUNCTION: wedge - the exterior power of a sheaf
   
CALLING SEQUENCE: wedge(p,A)
   
PARAMETERS: p - an integer
            A - (the Chern character of) a sheaf
   
SYNOPSIS:   
- wedge(p,A) returns the Chern character of the pth exterior power of the sheaf
  A, where A is represented by its Chern character.  The result is truncated
  in dimension DIM+1
   
EXAMPLES:   
   
> DIM:=4: b:=bundle(4,c): wedge(3,b);
   
                    2         2  2           3        3               3  3
   4 + 3 c1 t - c2 t  + 3/2 c1  t  - 1/2 c3 t  - 1/2 t  c1 c2 + 1/2 c1  t
   
                  4        4               4   2        4      2         4  4
        - 1/6 c4 t  - 1/3 t  c1 c3 + 1/12 t  c2  - 1/6 t  c2 c1  + 1/8 c1  t
   
SEE ALSO:  symm,Symm,schurfunctor,schurfunctor2
-------------------------------------------
FUNCTION: where - display the currentvariety_ and DIM variables
   
CALLING SEQUENCE: where()
   
PARAMETERS: none
   
SYNOPSIS:   
- the values of currentvariety_ and DIM are displayed.
   
EXAMPLES:   
   
> proj(2,h): where();
   
                      currentvariety_ is Ph, DIM is 2
   
SEE ALSO:  variety, DIM

-------------------------------------------
FUNCTION: whichcone - determines the smallest cone of a fan that a given
                      vector is contained in
   
CALLING SEQUENCE: whichcone(X,v)
   
PARAMETERS:  X - the name of a toricvariety
             v - an integer list
   
SYNOPSIS:
- returns the smallest cone of the fan for X that v is contained in.  The
  cone is described by a list of integers which correspond to the edges
  spanning the cone.
   
EXAMPLES:  
> wproj(X,x,[1,1,1,1]): print(X[edges_]): whichcone(X,[0,1,1]);
   
                                 [  1   1   1 ]
                                 [            ]
                                 [ -1   0   0 ]
                                 [            ]
                                 [  0  -1   0 ]
                                 [            ]
                                 [  0   0  -1 ]
   
                                     [1, 2]
   
SEE ALSO:  toricvariety, wproj, insertedge
   
-------------------------------------------
FUNCTION: wproj - construct a weighted projective space as a toric variety
   
CALLING SEQUENCES:
   wproj(X,h,w)
   wproj(X,h,w,options)
   
PARAMETERS:  X,h - names
             w - an integer list
             options - any of the options used to create a toricvariety:
                       Pic,int,bas,tan, or all
   
SYNOPSIS:
- The weighted projective space P(w) is constructed as a toric variety,
  and is stored as X.  h is used to generated names for the edges.
- The option Pic allows the user to specific a generator for Pic,
  exactly as in the toricvariety procedure
- The options int, bas, tan or all control the computation of the 
  intersection numbers, additive basis, and tangentbundle, exactly
  as in the toricvariety procedure.
   
EXAMPLES:  
> wproj(X,h,[1,1,2],Pic=[H=h1],int): integral(H^2);
   
                              Variety is singular
   
                                      1/2
   
SEE ALSO:  toricvariety, whichcone, insertedge

VI. GLOBAL VARIABLES 

Schubert maintains and uses a number of global variables. In addition to the
names of the procedures themselves, they are the following, ending in an
underscore:

dimension_, variables_, degrees_, relations_, point_, tangentbundle_,
toddclass_, monomials_, monomialvalues_, grelations_, upperstardata_,
kind_, lowerstar_, basevariety_, arank_, qrank_, source_, target_,
projectivebundle_, grassmannbundle_, structuremorphism_, basis_, 
dualbasis_, vectorbundle_, basedimension_, section_, fiber_, order_
quotientbundle_, bundlesection_, structuremap_, class_, product_,
currentvariety_,version_,betti_

and:

POINT, DIM, t.

Finally, there are some variables that are used by SF:

e.k, h.k, and p.k (k any integer) and m[...] and s[...] (where [...]
is any partition). 

The user is advised against using these variable names in a session with
schubert. The variables used by SF may be used as names, but they should 
not be assigned any value. For example,

> sheaf(4,[e1,e2,e3]): bundle(3,h): grass(3,6,p):

should present no problems, whereas an assignment like

> e1:=c1+c2+c3: # or Proj(p2,A,d)

will create unpredictable results.


WARNING: 
It is particularly easy to forget that t is a reserved variable! Never
use t as a name of a cycle class; you're bound to get wrong results.

VII. Troubleshooting

If you get suspiciously looking results, there are a number of things 
you can do to find out what is going on. The most common source of 
mistakes is the you assign a variable and forget about it. Very bad
things happen if you assign values to maple procedure names, such as
diff, for example (Maple uses diff in cases where you would not expect
it). Using the schubert reserved variable t will screw up everything. 
In this context, remember that schubert often assigns values to names
that are derived from other names. For example, if you have an 
inclusion morphism called B and blow it up, the blow up will be called
BB, the exceptional divisor class will be EB and so on.
	
If your schubert session has been long and you start getting errors,
you might try to quit and restart Maple. To produce a bug report, try
to make it from a fresh start.

A common source of mistakes is that DIM is sometimes changed by some
schubert command without informing the user of this fact, or perhaps
DIM is not updated when the user expects it. If DIM is smaller than
intended, wrong answers will result; if DIM is too large, computations
will take longer, and wrong results may also occur. Inserting where()
or setvariety() statements in your session will be a safeguard.

If you set infolevel[where]:=10 (for example in your .mapleinit file),
then you will get a message on the screen whenever a schubert command
changes the global variables currentvariety_ or DIM.

The real debugging tools are printlevel, trace, userinfo, and mint.

a. 	
You can execute a statement of the form printlevel:=n, where
n is an integer >1. Values like 6 or 11 will cause maple to print out 
lots of intermediate results, as well as entry and exit from procedures 
called, with arguments and returned values. See the maple documentation 
on printlevel. 

b.	
Another more specific tool is trace(procname), which will print
more than usual but only when a specific procedure is running. See the
Maple documentation on trace. (If you load the linalg package, the
trace procedure unfortunately gets overwritten by the trace function
of linear algebra. One way to get around this is to rename trace before
loading linalg, as follows: track:=eval(trace): with(linalg):)
	
c.	
If you browse through the source code for schubert, you'll see that 
there are some userinfo commands here and there. To get some more 
feedback on the screen, especially during long computations, you can
execute infolevel[debug]:=10, for example. To make any sense of this
output, you'll probably have to read the source code. 

d.	
Mint is a Maple diagnostic tool which is not run under Maple, but 
rather as an independent application. If you have written a Maple 
program and saved it to a file foo, then the unix command 'mint foo'
will produce information on the use of local and global variables and
so on. It will spot any syntactical error and some other errors as
well, and give warnings when something looks fishy. See the Maple 
documentation on Mint.

VIII.  Miscellaneous remarks  

There are probably still quite a number of bugs, anomalies and design
flaws in schubert. For the moment any user has to consider him/herself
a beta tester. Please report any bugs or mysterious behaviour, as well
as cases where computations seem to take too long time. Include code.
	 
It is easy to modify schubert commands, both with respect to what they
do and what parameters and options they accept. The parameter
structure of several commands are up for discussion. Let us know what
you find awkward in schubert.

It is also easy to add new commands to schubert, and there are plans
for adding several new ones. We welcome any ideas for stuff that would
be reasonably within the scope of the package. One idea that has come
up is to have built-in facilities for toric varieties. Others include
expressing cycles in a Grassmannian in terms of schubert cycles, and
encoding representation rings for certain groups in schubert.
